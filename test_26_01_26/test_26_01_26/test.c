#define _CRT_SECURE_NO_WARNINGS 1 
#include <stdio.h>
////"+"、"-"操作符
//int main()
//{
//	int a = 10, b = 5;
//	printf("%d %d\n", a + b, a + 3 - b); //打印结果为：15 8
//	return 0;
//}


////"*"、"/"操作符
//int main()
//{
//	int a = 10, b = 5;
//	float f = 3.14;
//	printf("%lf %lf\n", (a * b) / f, f * a); //打印结果为：15.923567 31.400002
//	
//	//对于除法来说，如果两个操作数均为整数，执行整数除法，否则执行小数除法
//	printf("%d\n", a / b); //打印结果为：2
//	return 0;
//}


////"%"操作符
//int main()
//{
//	int a = 10, b = 5;
//	printf("%d %d\n", a % b, b % 2); //打印结果为：0 1
//	//取模操作的两个操作数必须为整数，计算的结果是相除剩的余数
//	return 0;
//}


////移位操作符移动的是二进制位
//int main()
//{
//	int a = 3, b = a << 1; //a的二进制位左移1位
//	printf("%d %d\n", a, b); //打印结果为：3 6
//	//a的二进制是：0011（只取最低4位即可，高28位均为0）
//	//a<<1的结果是：0110（所有二进制位向左移动一位，高位丢弃，低位补0）
//	//移位操作符不会改变操作数本身，也就是无论怎么移动，a的值不会改变
//	return 0;
//}


////负数左移
//int main()
//{
//	int b = -3;
//	printf("%d\n", b << 1); //打印结果为：-6
//	//b的二进制原码为：10000000 00000000 00000000 00000011
//	//b的二进制反码为：11111111 11111111 11111111 11111100（符号位不变，其余按位取反）
//	//b的二进制补码为：11111111 11111111 11111111 11111101（反码+1）
//	//b<<1的补码为：11111111 11111111 11111111 11111010
//	//b<<1的反码为：10000000 00000000 00000000 00000101
//	//b<<1的原码为：10000000 00000000 00000000 00000110，转换为十进制为-6
//	return 0;
//}


////">>"操作符
//int main()
//{
//	int a = -5, b = a >> 1;
//	printf("%d\n", b); //打印结果为：-3
//	//a的原码：10000000 00000000 00000000 00000101
//	//a的反码：11111111 11111111 11111111 11111010
//	//a的补码：11111111 11111111 11111111 11111011
//	 
//	//b的原码：10000000 00000000 00000000 00000011
//	//b的反码：11111111 11111111 11111111 11111100
//	//b的补码：11111111 11111111 11111111 11111101
//
//	//从a的补码到b的补码可以发现，a的最低位"1"丢弃了，最高位补了"1"，也就是原来的符号位
//	//因此可知，VS下执行的是算术右移
//	return 0;
//}


////"&"操作符
//int main()
//{
//	int a = -5, b = 3;
//	printf("%d\n", a & b); //打印结果为：3
//	//a的原码：10000000 00000000 00000000 00000101
//	//a的反码：11111111 11111111 11111111 11111010
//	//a的补码：11111111 11111111 11111111 11111011
//	//b的原反补码：00000000 00000000 00000000 00000011
//	//"&"的规则是二进制位有0则0，全1为1
//	//a & b的补码：00000000 00000000 00000000 00000011
//	return 0;
//}


////"|"操作符
//int main()
//{
//	int a = -5, b = 3;
//	printf("%d\n", a | b); //打印结果为：-5
//	//a的原码：10000000 00000000 00000000 00000101
//	//a的反码：11111111 11111111 11111111 11111010
//	//a的补码：11111111 11111111 11111111 11111011
//	//b的原反补码：00000000 00000000 00000000 00000011
//	//"|"的规则是二进制位有1则1，全0为0
//	//a | b的补码：11111111 11111111 11111111 11111011
//	return 0;
//}


////"^"操作符
//int main()
//{
//	int a = -5, b = 3;
//	printf("%d\n", a ^ b); //打印结果为：-8
//	//a的原码：10000000 00000000 00000000 00000101
//	//a的反码：11111111 11111111 11111111 11111010
//	//a的补码：11111111 11111111 11111111 11111011
//	//b的原反补码：00000000 00000000 00000000 00000011
//	//"^"的规则是二进制位相同为0，不同为1
//	//a ^ b的补码：11111111 11111111 11111111 11111000
//	//a ^ b的反码：10000000 00000000 00000000 00000111
//	//a ^ b的原码：10000000 00000000 00000000 00001000
//	return 0;
//}


////不创建临时变量，实现两个数的交换
//int main()
//{
//	int a = 3, b = 5;
//	a = a + b; //a = 3 + 5 = 8
//	b = a - b; //b = 8 - 5 = 3
//	a = a - b; //a = 8 - 3 = 5
//	printf("a = %d, b = %d\n", a, b); //打印结果为：a = 5, b = 3
//
//	//上面的方法中，如果a和b是比较大的数，那么计算a + b就可能溢出，可以用"^"操作符
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	printf("a = %d, b = %d\n", a, b); //打印结果为：a = 3, b = 5
//
//	//"^"的特点是相同为0，不同为1，所以a ^ a = 0，a ^ 0 = a，并且异或支持交换律
//	//那么(a ^ b) ^ b = a ^ (b ^ b) = a ^ 0 = a，a ^ (a ^ b) = (a ^ a) ^ b = 0 ^ b = b
//	return 0;
//}


////赋值操作符
//int main()
//{
//	int a = 3;
//	a += 3; //相当于a = a + 3
//	a <<= 1; //相当于a = a << 1
//	a |= 5; //相当于a = a | 5
//	printf("%d\n", a); //打印结果为：13
//	return 0;
//}


////"!"操作符
//int main()
//{
//	int flag = 0;
//	if (flag) {} //变量flag为真时才执行语句
//	if (!flag) {} //变量flag为假时才执行语句
//	return 0;
//}


////"&"操作符
//int main()
//{
//	int a = 10;
//	int* pa = &a; //将a的地址存放到指针变量pa中
//	printf("%d\n", *pa); //解引用打印a的值
//
//	int arr[10];
//	int* parr = &arr; //取出整个数组的地址
//	return 0;
//}


////"sizeof"操作符
//int main()
//{
//	int a = 10;
//	printf("%d\n", sizeof(a)); //计算变量a的大小
//	printf("%d\n", sizeof(int)); //也可以这样写
//	printf("%d\n", sizeof a); //a的两端可以省略，int两端不能省略
//	return 0;
//}


////"~"操作符
//int main()
//{
//	int a = 0;
//	printf("%d\n", ~a); //打印结果为：-1
//	//"~"操作符的功能是将二进制位的0变1，1变0
//	//a的补码： 00000000 00000000 00000000 00000000
//	//~a的补码：11111111 11111111 11111111 11111111
//	//~a的反码：10000000 00000000 00000000 00000000
//	//~a的原码：10000000 00000000 00000000 00000001
//	return 0;
//}


////"++"、"--"操作符
//int main()
//{
//	int a = 3, b = 5;
//	a++;
//	printf("%d %d\n", a, b); //打印结果为：4 5
//	++b;
//	printf("%d %d\n", a, b); //打印结果为：4 6
//	a--;
//	printf("%d %d\n", a, b); //打印结果为：3 6
//	--b;
//	printf("%d %d\n", a, b); //打印结果为：3 5
//	return 0;
//}


////"(type)"操作符
//int main()
//{
//	int a = 10;
//	printf("%f\n", (float)a); //将a强转为float类型再输出
//	printf("%d\n", a); //实际上a并没有真的转换，强转只是一种临时状态
//	return 0;
//}


////"&&"操作符
//int main()
//{
//	int a = 10, b = 0;
//	printf("%d\n", a && b); //打印结果为：0
//	//"&&"操作符两边有一个为假，则整个表达式为假，两边全为真，整个表达式为真
//	//C语言中，0表示假，一切的非0表示真
//	return 0;
//}


////"||"操作符
//int main()
//{
//	int a = 10, b = 0;
//	printf("%d\n", a || b); //打印结果为：1
//	//"||"操作符两边有一个为真，则整个表达式为真，两边全为假，整个表达式为假
//	return 0;
//}


////笔试题
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	i = a++ && ++b && d++;
//	printf("i = %d, a = %d, b = %d, c = %d, d = %d\n", i, a, b, c, d); //打印结果为：i = 0, a = 1, b = 2, c = 3, d = 4
//	//a++的值是先用a的值0，再++，所以a++的结果是0，此时逻辑表达式为假
//	//对于逻辑表达式而言，如果"&&"逻辑表达式前面已经为假了，则后面不会被计算
//	//如果"||"逻辑表达式前面已经为真了，则后面也不会被计算
//	//之后a变为1，b没有被计算，值还是2，c不变，d同样没有被计算，值为4
//	return 0;
//}


////条件操作符代替if-else语句
//int main()
//{
//	//条件操作符形式：exp1 ? exp2 : exp3
//	//含义是如果exp1（表达式1）为真，则执行exp2，否则执行exp3
//	//条件操作符可以代替简单的if-else语句
//	
//	int a = 10;
//	if (a < 5)
//		printf("hehe\n");
//	else
//		printf("haha\n");
//
//	//用条件操作符代替上面的if-else语句
//	int b = (a < 5) ? (printf("hehe\n")) : (printf("haha\n"));
//	printf("%d\n", b); //打印结果为：5
//
//	//上面的条件表达式中，执行的是"printf("haha\n")"，所以整个表达式的结果就是该函数的返回值
//	printf("%d\n", printf("haha\n")); //打印结果为：5
//
//	//可以看出"printf("haha\n")"的返回值为5，这是因为printf()函数的返回值是输出的字符个数
//	//该函数输出'h'、'a'、'h'、'a'、'\n'共5个字符，所以返回5，因此整个条件表达式的结果为5
//	return 0;
//}


////用条件表达式判断两个数的较大值
//int main()
//{
//	int a = 0, b = 0;
//	scanf("%d %d", &a, &b);
//	printf("%d和%d的较大值为：%d\n", a, b, (a > b ? a : b));
//	return 0;
//}


////逗号表达式
//int main()
//{
//	int a = 1, b = 2;
//	printf("%d %d %d\n",a, b, (a > b, a = b + 10, b = a + 1)); //打印结果为：12 13 13
//	return 0;
//}


////下标引用操作符
//int main()
//{
//	int arr[10] = { 1, 2, 3, 4 };
//	printf("%d %d\n", arr[2], arr[1 + 4]); //这里的"[]"就是下标引用操作符
//	return 0;
//}


////函数调用操作符
//int Add(int x, int y)
//{
//	return x + y;
//}
//
//int main()
//{
//	int sum = Add(10, 20); //这里的"()"是函数调用操作符
//	printf("%d\n", sum); //打印结果为：30
//	return 0;
//}


////结构成员访问操作符
//struct S
//{
//	int num;
//	char c;
//};
//
//int main()
//{
//	struct S s = { 100, 'm' }; //创建结构体变量并初始化
//	struct S* ps = &s; //用结构体指针存放结构体变量
//	printf("%d %c\n", s.num, s.c); //用"."访问
//	printf("%d %c\n", ps->num, ps->c); //用"->"访问
//	return 0;
//}


////整型提升
//int main()
//{
//	char a = 3, b = 127, c = a + b;
//	printf("%d\n", c); //打印结果为：-126
//	//a的二进制为：00000011
//	//a整型提升后：00000000 00000000 00000000 00000011
//	//b的二进制为：01111111
//	//b整型提升后：00000000 00000000 00000000 01111111
//	//a+b的结果为：00000000 00000000 00000000 10000010
//	//将c存放到char类型中，要发生截断，取低8个二进制位：10000010【补】
//	//由于char是有符号数，使用"%d"打印有符号整型，因此再次进行整型提升
//	//在计算机中，10000010是一个负数，整型提升高位补符号位"1"
//	//11111111 11111111 11111111 10000010【补】
//	//10000000 00000000 00000000 01111101【反】
//	//10000000 00000000 00000000 01111110【原】
//	//转换成十进制为：-(2 + 4 + 8 + 16 + 32 + 64) = -126
//
// 
//	unsigned char d = a + b;
//	printf("%u\n", d); //打印结果为：130
//	//如果按照"%u"无符号整形打印，unsigned char是无符号数，则10000010【补】的原反补相同
//	//对于无符号数，整型提升高位补"0"
//	//00000000 00000000 00000000 10000010转成十进制为：2 + 128 = 130
//
// 
//	printf("%u\n", c); //打印结果为：4294967170
//	//如果依旧按照"%u"打印，同时用有符号char类型存储，10000010【补】按照有符号的整型提升
//	//对于有符号数，整型提升高位补符号位"1"
//	//11111111 11111111 11111111 10000010【原反补相同】转换成十进制为：4294967170
//	return 0;
//}


////整型提升
//int main()
//{
//	char a = 0xb6;
//	short b = 0xb600;
//	int c = 0xb6000000;
//
//	if (a == 0xb6)
//		printf("a\n");
//	if (b == 0xb600)
//		printf("b\n");
//	if (c == 0xb6000000)
//		printf("c\n");
//
//	printf("%d %d\n", a, 0xb6);
//	printf("%d %d\n", b, 0xb600);
//	printf("%d %d\n", c, 0xb6000000);
//
//	//十六进制的"b6"转换为十进制数为：11 × 16 + 6 = 182
//	//182转换为二进制数为：10110110，已经超过了char所表示的范围（-128 ~ 127）
//	//a整型提升后：11111111 11111111 11111111 10110110【补】（char是有符号数，高位补符号位"1"）
//	//a截断后：10110110【补】
//	//用"%d"打印，再次整型提升：11111111 11111111 11111111 10110110【补】
//	//转换为反码：10000000 00000000 00000000 01001001【反】
//	//转换为原码：10000000 00000000 00000000 01001010【原】
//	//转换为十进制为：-(2 + 8 + 64) = -74，与0xb6不等
//
//	//十六进制的"b600"转换为十进制数为：11 × 16 × 16 × 16 + 6 × 16 × 16 = 45056 + 1536 = 46592
//	//46592转换为二进制数为：10110110 00000000，已经超过了short所表示的范围（-32768 ~ 32767）
//	//b整型提升后：11111111 11111111 10110110 00000000【补】（short是有符号数，高位补符号位"1"）
//	//b截断后：10110110 00000000【补】
//	//用"%d"打印，再次整型提升：11111111 11111111 10110110 00000000【补】
//	//转换为反码：10000000 00000000 01001001 11111111【反】
//	//转换为原码：10000000 00000000 01001010 00000000【原】
//	//转换为十进制为：-18944，与0xb6不等
//
//	//十六进制的"b6000000"转换为二进制数为：10110110 00000000 00000000 00000000【补】
//	//转换为十进制为：-1241513984（因为这个数用"int"类型存储，所以是有符号数，最高位是符号位）
//	//c不需要整型提升：10110110 00000000 00000000 00000000【补】
//	//用"%d"打印，转换成反码：11001001 11111111 11111111 11111111【反】
//	//转换成原码：11001010 00000000 00000000 00000000【原】
//	//转换为十进制为：-1241513984，与0xb6000000相等
//	return 0;
//}


//整型提升
int main()
{
	char c = -1;
	printf("%zu %zu %zu\n", sizeof(c), sizeof(+c), sizeof(-c)); //打印结果为：1 4 4
	//sizeof(c)计算的是变量c的大小，也就是"char"类型的大小，结果是1个字节
	//计算"+c"和"-c"时，会进行整型提升，提升到"int"类型，所以结果是4个字节
	return 0;
}